{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-maskedinput.min.js","webpack:///webpack/bootstrap 4d084f347c38c601d1ff","webpack:///./src/index.js","webpack:///./~/inputmask-core/lib/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_objectWithoutProperties","obj","keys","target","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","isUndo","e","ctrlKey","metaKey","keyCode","shiftKey","KEYCODE_Y","KEYCODE_Z","isRedo","getSelection","el","start","end","rangeEl","clone","undefined","selectionStart","selectionEnd","focus","createTextRange","duplicate","moveToBookmark","document","selection","createRange","getBookmark","setEndPoint","text","length","setSelection","activeElement","setSelectionRange","collapse","moveStart","moveEnd","select","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_inputmask_core__","__WEBPACK_IMPORTED_MODULE_1_inputmask_core___default","_extends","assign","arguments","source","key","isAndroid","navigator","userAgent","match","MaskedInput","_React$Component","props","_this","_onChange","bind","_onKeyDown","_onPaste","_onKeyPress","componentWillMount","options","pattern","mask","formatCharacters","placeholderChar","a","componentWillReceiveProps","nextProps","setPattern","getRawValue","setValue","componentWillUpdate","nextState","_updatePattern","componentDidUpdate","prevProps","_updateInputSelection","input","_updateMaskSelection","maskValue","getValue","sizeDiff","backspace","_getDisplayValue","onChange","preventDefault","undo","redo","altKey","data","setTimeout","paste","clipboardData","getData","emptyValue","_keyPressPropName","_getEventHandlers","_ref","onKeyDown","onPaste","blur","render","_this2","ref","r","maxLength","eventHandlers","_props","_props$size","size","_props$placeholder","placeholder","_props2","cleanedProps","inputProps","createElement","Component","defaultProps","extend","dest","src","copy","mergeFormatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","char","Pattern","isRevealingMask","DEFAULT_PLACEHOLDER_CHAR","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","InputMask","Error","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","*","validate","test","1","A","transform","toUpperCase","#","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","selectionBefore","valueBefore","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","initialState","slice","charAt","substring","historyItem","startUndo","pop","join","_resetHistory","rawValue"],"mappings":"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","file":"react-maskedinput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inputmask_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inputmask_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_inputmask_core__);\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar KEYCODE_Z = 90;\nvar KEYCODE_Y = 89;\n\nvar isAndroid = typeof navigator !== 'undefined' && navigator.userAgent.match(/Android/i);\n\nfunction isUndo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z);\n}\n\nfunction isRedo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y);\n}\n\nfunction getSelection(el) {\n  var start, end, rangeEl, clone;\n\n  if (el.selectionStart !== undefined) {\n    start = el.selectionStart;\n    end = el.selectionEnd;\n  } else {\n    try {\n      el.focus();\n      rangeEl = el.createTextRange();\n      clone = rangeEl.duplicate();\n\n      rangeEl.moveToBookmark(document.selection.createRange().getBookmark());\n      clone.setEndPoint('EndToStart', rangeEl);\n\n      start = clone.text.length;\n      end = start + rangeEl.text.length;\n    } catch (e) {/* not focused or not visible */}\n  }\n\n  return { start: start, end: end };\n}\n\nfunction setSelection(el, selection) {\n  var rangeEl;\n\n  // don't set selection if el is not focused\n  if (el !== document.activeElement) {\n    return;\n  }\n\n  try {\n    if (el.selectionStart !== undefined) {\n      el.focus();\n      el.setSelectionRange(selection.start, selection.end);\n    } else {\n      el.focus();\n      rangeEl = el.createTextRange();\n      rangeEl.collapse(true);\n      rangeEl.moveStart('character', selection.start);\n      rangeEl.moveEnd('character', selection.end - selection.start);\n      rangeEl.select();\n    }\n  } catch (e) {/* not focused or not visible */}\n}\n\nvar MaskedInput = function (_React$Component) {\n  _inherits(MaskedInput, _React$Component);\n\n  function MaskedInput(props) {\n    _classCallCheck(this, MaskedInput);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this._onChange = _this._onChange.bind(_this);\n    _this._onKeyDown = _this._onKeyDown.bind(_this);\n    _this._onPaste = _this._onPaste.bind(_this);\n    _this._onKeyPress = _this._onKeyPress.bind(_this);\n    return _this;\n  }\n\n  MaskedInput.prototype.componentWillMount = function componentWillMount() {\n    var options = {\n      pattern: this.props.mask,\n      value: this.props.value,\n      formatCharacters: this.props.formatCharacters\n    };\n    if (this.props.placeholderChar) {\n      options.placeholderChar = this.props.placeholderChar;\n    }\n    this.mask = new __WEBPACK_IMPORTED_MODULE_1_inputmask_core___default.a(options);\n  };\n\n  MaskedInput.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, { value: nextProps.value });\n    } else if (this.props.mask !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, { value: this.mask.getRawValue() });\n    } else if (this.props.value !== nextProps.value) {\n      this.mask.setValue(nextProps.value);\n    }\n  };\n\n  MaskedInput.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {\n    if (nextProps.mask !== this.props.mask) {\n      this._updatePattern(nextProps);\n    }\n  };\n\n  MaskedInput.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n      this._updateInputSelection();\n    }\n  };\n\n  MaskedInput.prototype._updatePattern = function _updatePattern(props) {\n    this.mask.setPattern(props.mask, {\n      value: this.mask.getRawValue(),\n      selection: getSelection(this.input)\n    });\n  };\n\n  MaskedInput.prototype._updateMaskSelection = function _updateMaskSelection() {\n    this.mask.selection = getSelection(this.input);\n  };\n\n  MaskedInput.prototype._updateInputSelection = function _updateInputSelection() {\n    setSelection(this.input, this.mask.selection);\n  };\n\n  MaskedInput.prototype._onChange = function _onChange(e) {\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\n    var maskValue = this.mask.getValue();\n    if (e.target.value !== maskValue) {\n      // Cut or delete operations will have shortened the value\n      if (e.target.value.length < maskValue.length) {\n        var sizeDiff = maskValue.length - e.target.value.length;\n        this._updateMaskSelection();\n        this.mask.selection.end = this.mask.selection.start + sizeDiff;\n        this.mask.backspace();\n      }\n      var value = this._getDisplayValue();\n      e.target.value = value;\n      if (value) {\n        this._updateInputSelection();\n      }\n    }\n    if (this.props.onChange) {\n      this.props.onChange(e);\n    }\n  };\n\n  MaskedInput.prototype._onKeyDown = function _onKeyDown(e) {\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    if (isUndo(e)) {\n      e.preventDefault();\n      if (this.mask.undo()) {\n        e.target.value = this._getDisplayValue();\n        this._updateInputSelection();\n        if (this.props.onChange) {\n          this.props.onChange(e);\n        }\n      }\n      return;\n    } else if (isRedo(e)) {\n      e.preventDefault();\n      if (this.mask.redo()) {\n        e.target.value = this._getDisplayValue();\n        this._updateInputSelection();\n        if (this.props.onChange) {\n          this.props.onChange(e);\n        }\n      }\n      return;\n    }\n\n    if (e.key === 'Backspace') {\n      e.preventDefault();\n      this._updateMaskSelection();\n      if (this.mask.backspace()) {\n        var value = this._getDisplayValue();\n        e.target.value = value;\n        if (value) {\n          this._updateInputSelection();\n        }\n        if (this.props.onChange) {\n          this.props.onChange(e);\n        }\n      }\n    }\n  };\n\n  MaskedInput.prototype._onKeyPress = function _onKeyPress(e) {\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    // Ignore modified key presses\n    // Ignore enter key to allow form submission\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') {\n      return;\n    }\n\n    e.preventDefault();\n    this._updateMaskSelection();\n    if (this.mask.input(e.key || e.data)) {\n      e.target.value = this.mask.getValue();\n      this._updateInputSelection();\n      if (this.props.onChange) {\n        this.props.onChange(e);\n      }\n      // Needed for Android Chrome Galaxy S\n      if (isAndroid) {\n        setTimeout(this._updateInputSelection.bind(this), 0);\n      }\n    }\n  };\n\n  MaskedInput.prototype._onPaste = function _onPaste(e) {\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\n    e.preventDefault();\n    this._updateMaskSelection();\n    // getData value needed for IE also works in FF & Chrome\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n      e.target.value = this.mask.getValue();\n      // Timeout needed for IE\n      setTimeout(this._updateInputSelection.bind(this), 0);\n      if (this.props.onChange) {\n        this.props.onChange(e);\n      }\n    }\n  };\n\n  MaskedInput.prototype._getDisplayValue = function _getDisplayValue() {\n    var value = this.mask.getValue();\n    return value === this.mask.emptyValue ? '' : value;\n  };\n\n  MaskedInput.prototype._keyPressPropName = function _keyPressPropName() {\n    return isAndroid ? 'onBeforeInput' : 'onKeyPress';\n  };\n\n  MaskedInput.prototype._getEventHandlers = function _getEventHandlers() {\n    var _ref;\n\n    return _ref = {\n      onChange: this._onChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste\n    }, _ref[this._keyPressPropName()] = this._onKeyPress, _ref;\n  };\n\n  MaskedInput.prototype.focus = function focus() {\n    this.input.focus();\n  };\n\n  MaskedInput.prototype.blur = function blur() {\n    this.input.blur();\n  };\n\n  MaskedInput.prototype.render = function render() {\n    var _this2 = this;\n\n    var ref = function ref(r) {\n      _this2.input = r;\n    };\n    var maxLength = this.mask.pattern.length;\n    var value = this._getDisplayValue();\n    var eventHandlers = this._getEventHandlers();\n    var _props = this.props,\n        _props$size = _props.size,\n        size = _props$size === undefined ? maxLength : _props$size,\n        _props$placeholder = _props.placeholder,\n        placeholder = _props$placeholder === undefined ? this.mask.emptyValue : _props$placeholder;\n\n    var _props2 = this.props,\n        placeholderChar = _props2.placeholderChar,\n        formatCharacters = _props2.formatCharacters,\n        cleanedProps = _objectWithoutProperties(_props2, ['placeholderChar', 'formatCharacters']); // eslint-disable-line\n\n\n    var inputProps = _extends({}, cleanedProps, eventHandlers, { ref: ref, maxLength: maxLength, value: value, size: size, placeholder: placeholder });\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('input', inputProps);\n  };\n\n  return MaskedInput;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);\n\nMaskedInput.defaultProps = {\n  value: ''\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MaskedInput);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-maskedinput.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4d084f347c38c601d1ff","import React from 'react'\nimport PropTypes from 'prop-types'\nimport InputMask from 'inputmask-core'\n\nvar KEYCODE_Z = 90\nvar KEYCODE_Y = 89\n\nvar isAndroid = typeof navigator !== 'undefined' &&\n  navigator.userAgent.match(/Android/i);\n\nfunction isUndo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z)\n}\n\nfunction isRedo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y)\n}\n\nfunction getSelection (el) {\n  var start, end, rangeEl, clone\n\n  if (el.selectionStart !== undefined) {\n    start = el.selectionStart\n    end = el.selectionEnd\n  }\n  else {\n    try {\n      el.focus()\n      rangeEl = el.createTextRange()\n      clone = rangeEl.duplicate()\n\n      rangeEl.moveToBookmark(document.selection.createRange().getBookmark())\n      clone.setEndPoint('EndToStart', rangeEl)\n\n      start = clone.text.length\n      end = start + rangeEl.text.length\n    }\n    catch (e) { /* not focused or not visible */ }\n  }\n\n  return { start, end }\n}\n\nfunction setSelection(el, selection) {\n  var rangeEl\n\n  // don't set selection if el is not focused\n  if (el !== document.activeElement) {\n    return;\n  }\n\n  try {\n    if (el.selectionStart !== undefined) {\n      el.focus()\n      el.setSelectionRange(selection.start, selection.end)\n    }\n    else {\n      el.focus()\n      rangeEl = el.createTextRange()\n      rangeEl.collapse(true)\n      rangeEl.moveStart('character', selection.start)\n      rangeEl.moveEnd('character', selection.end - selection.start)\n      rangeEl.select()\n    }\n  }\n  catch (e) { /* not focused or not visible */ }\n}\n\nclass MaskedInput extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this._onChange = this._onChange.bind(this)\n    this._onKeyDown = this._onKeyDown.bind(this)\n    this._onPaste = this._onPaste.bind(this)\n    this._onKeyPress = this._onKeyPress.bind(this)\n  }\n\n  componentWillMount() {\n    var options = {\n      pattern: this.props.mask,\n      value: this.props.value,\n      formatCharacters: this.props.formatCharacters\n    }\n    if (this.props.placeholderChar) {\n      options.placeholderChar = this.props.placeholderChar\n    }\n    this.mask = new InputMask(options)\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, { value: nextProps.value });\n    }\n    else if (this.props.mask !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n    }\n    else if (this.props.value !== nextProps.value) {\n      this.mask.setValue(nextProps.value)\n    }\n  }\n\n  componentWillUpdate(nextProps, nextState) {\n    if (nextProps.mask !== this.props.mask) {\n      this._updatePattern(nextProps)\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n      this._updateInputSelection()\n    }\n  }\n\n  _updatePattern(props) {\n    this.mask.setPattern(props.mask, {\n      value: this.mask.getRawValue(),\n      selection: getSelection(this.input)\n    })\n  }\n\n  _updateMaskSelection() {\n    this.mask.selection = getSelection(this.input)\n  }\n\n  _updateInputSelection() {\n    setSelection(this.input, this.mask.selection)\n  }\n\n  _onChange(e) {\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\n    var maskValue = this.mask.getValue()\n    if (e.target.value !== maskValue) {\n      // Cut or delete operations will have shortened the value\n      if (e.target.value.length < maskValue.length) {\n        var sizeDiff = maskValue.length - e.target.value.length\n        this._updateMaskSelection()\n        this.mask.selection.end = this.mask.selection.start + sizeDiff\n        this.mask.backspace()\n      }\n      var value = this._getDisplayValue()\n      e.target.value = value\n      if (value) {\n        this._updateInputSelection()\n      }\n    }\n    if (this.props.onChange) {\n      this.props.onChange(e)\n    }\n  }\n\n  _onKeyDown(e) {\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    if (isUndo(e)) {\n      e.preventDefault()\n      if (this.mask.undo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n    else if (isRedo(e)) {\n      e.preventDefault()\n      if (this.mask.redo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n\n    if (e.key === 'Backspace') {\n      e.preventDefault()\n      this._updateMaskSelection()\n      if (this.mask.backspace()) {\n        var value = this._getDisplayValue()\n        e.target.value = value\n        if (value) {\n          this._updateInputSelection()\n        }\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n    }\n  }\n\n  _onKeyPress(e) {\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    // Ignore modified key presses\n    // Ignore enter key to allow form submission\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') { return }\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    if (this.mask.input((e.key || e.data))) {\n      e.target.value = this.mask.getValue()\n      this._updateInputSelection()\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n      // Needed for Android Chrome Galaxy S\n      if (isAndroid) {\n        setTimeout(this._updateInputSelection.bind(this), 0)\n      }\n    }\n  }\n\n  _onPaste(e) {\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    // getData value needed for IE also works in FF & Chrome\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n      e.target.value = this.mask.getValue()\n      // Timeout needed for IE\n      setTimeout(this._updateInputSelection.bind(this), 0)\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  }\n\n  _getDisplayValue() {\n    var value = this.mask.getValue()\n    return value === this.mask.emptyValue ? '' : value\n  }\n\n  _keyPressPropName() {\n    return isAndroid ? 'onBeforeInput' : 'onKeyPress';\n  }\n\n  _getEventHandlers() {\n    return {\n      onChange: this._onChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste,\n      [this._keyPressPropName()]: this._onKeyPress\n    }\n  }\n\n  focus() {\n    this.input.focus()\n  }\n\n  blur() {\n    this.input.blur()\n  }\n\n  render() {\n    var ref = r => { this.input = r }\n    var maxLength = this.mask.pattern.length\n    var value = this._getDisplayValue()\n    var eventHandlers = this._getEventHandlers()\n    var { size = maxLength, placeholder = this.mask.emptyValue } = this.props\n\n    var { placeholderChar, formatCharacters, ...cleanedProps } = this.props // eslint-disable-line\n    var inputProps = { ...cleanedProps, ...eventHandlers, ref, maxLength, value, size, placeholder }\n    return <input {...inputProps} />\n  }\n}\n\nMaskedInput.propTypes = {\n  mask: PropTypes.string.isRequired,\n\n  formatCharacters: PropTypes.object,\n  placeholderChar: PropTypes.string\n}\n\nMaskedInput.defaultProps = {\n  value: ''\n}\n\nexport default MaskedInput\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask-core/lib/index.js\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}